# Carry Look-Ahead Adder (CLA)

A **Carry Look-Ahead Adder (CLA)** is a digital adder designed to **speed up binary addition** by **reducing the delay caused by ripple carry** in a Ripple Carry Adder (RCA).  

Instead of waiting for the carry to propagate through all stages, the CLA **calculates carry signals in advance** using **generate (G) and propagate (P) signals**.

---

##  Working Principle

1. **Inputs**: Two n-bit numbers `A = A[n-1:0]` and `B = B[n-1:0]`, and an input carry `Cin`.
2. **Generate (G) and Propagate (P) Signals**:


- `Ai & Bi` → **both inputs are 1**, so a carry is generated automatically.  
- `(Ai ^ Bi) & Cin` → **exactly one input is 1**, so carry from the previous stage is propagated.

---

## Generate (G) and Propagate (P)

To speed up multi-bit addition, CLA separates carry logic:

### Generate (G)

Gi = Ai & Bi


- Meaning: “This bit will **generate a carry** no matter what Cin is.”  
-
   Example: Ai=1, Bi=1 → G=1 → carry is guaranteed.

### Propagate (P)

Pi = Ai ^ Bi


- Meaning: “This bit will **propagate the incoming carry**.”  
- Example: Ai=0, Bi=1 → P=1 → carry from previous bit passes through.  
- If Pi=0 → no carry passes through unless generated by this bit itself.

---

## Why XOR for Propagate?

- XOR (`^`) = 1 when exactly one input is 1.  
- Propagation occurs **only when exactly one input is 1**.

| Ai | Bi | Pi = Ai^Bi | Meaning                |
|----|----|------------|-----------------------|
| 0  | 0  | 0          | No carry passes       |
| 0  | 1  | 1          | Carry passes          |
| 1  | 0  | 1          | Carry passes          |
| 1  | 1  | 0          | Carry already generated (G=1) |

---

## Why AND for Generate?

- AND (`&`) = 1 **only when both inputs are 1** → carry is generated.

| Ai | Bi | Gi = Ai & Bi | Meaning       |
|----|----|--------------|---------------|
| 0  | 0  | 0            | No carry      |
| 0  | 1  | 0            | No carry      |
| 1  | 0  | 0            | No carry      |
| 1  | 1  | 1            | Carry always  |

---


## Carry Calculation


- Carry-out for each bit is calculated **directly using G, P, and Cin**

- # General Carry Calculation Concept in CLA

For **any bit `i`** in a Carry Look-Ahead Adder, the carry into the next bit (`Ci+1`) can be expressed as:

```

Ci+1 = Gi | (Pi & Gi-1) | (Pi & Pi-1 & Gi-2) | ... | (Pi & Pi-1 & ... & P0 & C0)

```

# How Carry is Calculated Step by Step in a 4-bit CLA

In a **4-bit Carry Look-Ahead Adder (CLA)**, the carry for each bit is calculated using **Generate (G) and Propagate (P) signals**. This allows all carries to be determined in parallel, unlike a Ripple Carry Adder.

---

### 1️⃣ C0 = Cin
- The first carry is just the **input carry**.

---

### 2️⃣ C1 = G0 | (P0 & C0)
- Carry at bit 1 happens if:
  - **Bit 0 generates a carry** (`G0`), OR  
  - **Bit 0 propagates the previous carry** (`P0 & C0`)

---

### 3️⃣ C2 = G1 | (P1 & G0) | (P1 & P0 & C0)
- Carry at bit 2 happens if:
  - **Bit 1 generates a carry** (`G1`), OR  
  - **Bit 1 propagates carry from bit 0** (`P1 & G0`), OR  
  - **Both bit 1 and bit 0 propagate the input carry** (`P1 & P0 & C0`)

---

### 4️⃣ C3 = G2 | (P2 & G1) | (P2 & P1 & G0) | (P2 & P1 & P0 & C0)
- Carry at bit 3 happens if:
  - **Bit 2 generates a carry** (`G2`), OR  
  - **Bit 2 propagates carry from bit 1** (`P2 & G1`), OR  
  - **Bits 2 and 1 propagate carry from bit 0** (`P2 & P1 & G0`), OR  
  - **All previous bits propagate the input carry** (`P2 & P1 & P0 & C0`)

---

### 5️⃣ C4 = G3 | (P3 & G2) | (P3 & P2 & G1) | (P3 & P2 & P1 & G0) | (P3 & P2 & P1 & P0 & C0)
- Final carry out happens if:
  - **Bit 3 generates a carry**, OR  
  - **It propagates carries from previous bits**, OR  
  - **All previous bits propagate the input carry**

---

✅ **Key Point:**  
- Each carry can come from **generation at that bit** or **propagation from any previous bit**.  
- CLA computes all carries **in parallel**, which makes it faster than the Ripple Carry Adder.



